* **리스트**

   - 입력 순서 유지, 동적 배열로 구현된다.

     **[리스트의 주요 연산 시간 복잡도]**

     - len(a) : O(1)

     - a[i] : O(1)

     - a[i : j] : O(k)   #i부터 j까지 k개에 대해 조회

     - i  in  a : O(n)  # i가 a list에 존재하는지 순차 탐색하며 확인

     - a.count(i) : O(n)

     - a.index(i) : O(n)

     - **a.append(i) : O(1)**

     - **a.pop() : O(1)**  # list의 마지막 요소 추출 - 스택 연산

     - **a.pop(0) : O(n)**  # list의 첫번째 요소 추출 - 큐 연산 (큐 연산을 사용할 땐 list 대신 데크를 권장함; O(1) )

       - **deque** : 스택과 큐가 결합한 자료구조, **양쪽 끝에서 데이터들을 삽입/삭제**

     - del a[i] : O(n)  #최악의 경우

     - a.sort( ) : O(n log n) #팀소트 사용, 최선의 경우 O(n)

     - min(a), max(a) : O(n)

     - a.reverse( ) : O(n)

       

  - 리스트 활용 방법 : 다양한 자료형을 하나의 리스트에서 관리 가능

    > a= list()

    > a=[]

    - **insert( )** : 특정 인덱스에 특정 원소 삽입 

      > a. insert(3, 5)    # 3번째 인덱스에 5 삽입

    - 슬라이싱 기능 : 특정 인덱스 범위의 값 추출

      > a[인덱스:인덱스] 또는 a[인덱스:인덱스:step] 형태로 사용

    - **원소 삭제 기능**

      > del a[1]    # 1인덱스의 원소 삭제

      > a.remove(3)    # 3이라는 원소 삭제

      > a.pop(3)    # 스택 연산처럼, 원소3을 리턴한 뒤 list에서 삭제

      

  - 리스트의 특징
    - 리스트는 원소들에 대한 포인터 목록을 갖는 구조체로 선언되어있음
    - list의 각 원소들은 객체로서 저장되며, 이들 객체에 대한 포인터 목록을 관리함
    - 즉, 배열과 연결리스트를 합친듯한 형태를 자랑함



- **딕셔너리** : 내부적으로 해시 테이블로 구현되어 있음

  1) 인덱스로서 숫자, 문자, 집합 등 모든 객체를 모두 ''키''로 사용 가능하며 이러한 과정  

  ​     을 해싱이라고함

  2)  해시 테이블 시간 복잡도 : 입력/조회 모두 O(1)

  3)  즉, **딕셔너리의 연산 시간 복잡도**는 모두 **O(1)**

  4)  Python 3.7+ 부터 딕셔너리 입력 순서 유지

  5)  **collections** 모듈을 적극 사용함

  

  - 딕셔너리 활용 방법

    > a = dict()

    > a = {}

    - **items()** : 딕셔너리의 key, value를 각각 추출

      > for  k,v  in  a.items() : print(k,v)

    - 삭제 기능

      > del a['key1']    # 해당 key와 val 삭제

    

  - 딕셔너리 모듈

    - defaultdict 객체 : 존재하지 않는 키를 조회할 경우 에러 대신 디폴트 값을 생성

      > a = collections.defaultdict(int) #현재 a는 빈 딕셔너리
      >
      > a['c'] +=1
      >
      > a   # 에러x -> 디폴트 0 자동 생성 후 +1 계산 -> 'c' : 1 이 출력됨

    - Counter 객체 : 아이템 개수를 딕셔너리 형태로 리턴

      > a = [1,2,3,4,5,5,5,6,6]
      >
      > b = collections.Counter(a)
      >
      > b   # Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})

      > b.most_common(2) # [(5, 3), (6, 2)] 출력 : 빈도수가 높은 2개의 요소 추출

    - OrderedDict 객체 : 입력순서를 유지

      > collections.OrderedDict({'b': 3, 'a': 4, 'p': 1}) # 이 순서로 딕셔너리에 저장됨

      *하지만 파이썬 3.7부터 딕셔너리 입력 순서가 유지되어 더이상 OrderedDict는 사용되지 않음*

